/*
Copyright (C) 2015-2016 LiveCode Ltd.

This file is part of LiveCode.

LiveCode is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License v3 as published by the Free
Software Foundation.

LiveCode is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.

You should have received a copy of the GNU General Public License
along with LiveCode.  If not see <http://www.gnu.org/licenses/>.  */

/**
The navigation RAD widget is an upgrade to the navbar widget and is
intended for use in mobile apps for switching between cards,
although there are many other possible uses.

The widget displays a row of navigation items.  Each of these has a
<itemNames|name>, which identifies it.  Depending on the selected
<itemStyle>, the items may display a <itemLabels|label>,
<itemIcons|icon>, or both.  All of the navigation item data is
available as a single array via the <itemArray> property.

At any time, one of the navigation items may be
<hilitedItemName|highlighted>.  This is useful, for example, for
indicating the current card.  When the user clicks one of the
navigation items, the widget sends a <hiliteChanged> message.

References: hiliteChanged(message), preHiliteChanged(message),
hilitedItem(property), hilitedItemName(property),
preHilitedItem(property), preHilitedItemName(property),
itemArray(property), itemIcons(property), itemLabels(property),
itemNames(property), itemStyle(property)

Name: hiliteChanged
Type: message
Syntax: hiliteChanged
Summary: Sent when a navigation item is selected

Example:
on hiliteChanged
	go card the hilitedItemName of me
end hiliteChanged

Description:
The <hiliteChanged> message is sent when the highlighted navigation
item changes, either by clicking on the navigation rad or by setting
the <hilitedItem> or <hilitedItemName> properties.

References: hilitedItem (property), hilitedItemName (property)

Name: preHiliteChanged
Type: message
Syntax: preHiliteChanged
Summary: Sent when a navigation item is clicked but not yet selected.

Example:
on preHiliteChanged
   answer "Pre hilite. Do it?" with "Yes" and "No"
   if it = "Yes" then
      set the hiliteditem of the target to
		the prehiliteditem of the target
   end if
end preHiliteChangedd

Description:
If the <autoRADHilite>(Auto Hilite in property inspector) property is false
then The <preHiliteChanged> message is sent when the navigation item is clicked.
The hiliteChanged message is not sent. The hilitedItem or hilitedItemName properties
are also not set. To trigger the hiliteChanged message and hilite the icon,
set the hilitedItem or hilitedItemName.
Existing navbar hiliteChanged handlers require no changes.

References: preHilitedItem (property), preHilitedItemName (property), autoRADHilite (property)

Name: hiliteColor
Type: Property
Syntax: set the hiliteColor of <widget> to <color>
Syntax: get the hiliteColor of <widget>

Summary: The color of the highlighted navigation item

Description:
The <hiliteColor> is used to draw the icon and/or label of the
navigation item that is <hilitedItemName|currently highlighted>.

Related: hilitedItemName(property)

Name: foreColor
Type: property
Syntax: set the foreColor of <widget> to <color>
Syntax: get the foreColor of <widget>

Summary: The color of the navigation items that are not highlighted

Description:
The <foreColor> is used to draw the icons and/or labels of the
navigation items that are not <hilitedItemName|currently highlighted>.

Related: hilitedItemName(property)

Name: backColor
Type: property
Syntax: set the backColor of <widget> to <color>
Syntax: get the backColor of <widget>

Summary: The color of the navigation rad background

Description:
When the navigation rad has an <opaque> background, it is filled with
the <backColor>.

Related: opaque(property)

Name: borderColor
Type: property
Syntax: set the borderColor of <widget> to <color>
Syntax: get the borderColor of <widget>

Summary: The color of the navigation rad border

Description:
The top border of the navigation rad is drawn using the <borderColor>.

Related: showBorder(property)
*/

-- declaring extension as widget, followed by identifier
widget com.livecode.widget.navrad
--

-- dependancy declarations
use com.livecode.canvas
use com.livecode.widget
use com.livecode.engine
use com.livecode.library.iconsvg
use com.livecode.library.widgetutils
--

-- adding metadata to ensure the extension displays correctly in livecode
metadata author is "LiveCode. Improved by Ralph DiMola & mikey"
metadata version is "2.5.4"
metadata title is "Navigation RAD"
metadata preferredSize is "320,49"
metadata svgicon is "M3,4.2v29.5h80.2V4.2H3z M14.8,11.5c1-0.2,2.5-0.3,3.8-0.3c2.1,0,3.5,0.4,4.5,1.3c0.8,0.7,1.2,1.7,1.2,2.9	c0,2-1.3,3.4-2.9,4v0.1c1.2,0.4,1.9,1.5,2.3,3.1c0.5,2.2,0.9,3.7,1.2,4.3h-2.1c-0.3-0.4-0.6-1.8-1-3.7c-0.5-2.1-1.3-2.9-3.1-3h-1.9v6.7h-2V11.5z M16.8,18.6h2c2.1,0,3.5-1.2,3.5-2.9c0-2-1.4-2.9-3.6-2.9c-1,0-1.7,0.1-2,0.2V18.6z M39.5,22l-1.6,4.9h-2.1l5.3-15.5	h2.4l5.3,15.5h-2.1L45,22H39.5z M44.6,20.4L43,15.9c-0.3-1-0.6-1.9-0.8-2.8h0C42,14,41.7,15,41.4,15.9l-1.5,4.5H44.6z M60.8,11.5c1.2-0.2,2.7-0.3,4.3-0.3c2.9,0,4.9,0.7,6.3,1.9c1.4,1.3,2.2,3.1,2.2,5.6c0,2.5-0.8,4.6-2.2,6c-1.4,1.4-3.8,2.2-6.9,2.2	c-1.4,0-2.6-0.1-3.6-0.2V11.5z M62.8,25.2c0.5,0.1,1.2,0.1,2,0.1c4.3,0,6.6-2.4,6.6-6.6c0-3.7-2-6-6.3-6c-1,0-1.8,0.1-2.3,0.2V25.2z"

----------------------------------------------------------------

-- Metadata for re-used engine-level control properties

metadata hiliteColor.editor is "com.livecode.pi.color"
metadata hiliteColor.label is "Selected item color"
metadata hiliteColor.section is "Colors"
metadata hiliteColor.default is "10,95,244"

metadata foregroundColor.editor is "com.livecode.pi.color"
metadata foregroundColor.label is "Item color"
metadata foregroundColor.section is "Colors"
metadata foregroundColor.default is "128,128,128"

metadata backgroundColor.editor is "com.livecode.pi.color"
metadata backgroundColor.label is "Background color"
metadata backgroundColor.section is "Colors"
metadata backgroundColor.default is "244,244,244"

metadata borderColor.editor is "com.livecode.pi.color"
metadata borderColor.label is "Border color"
metadata borderColor.section is "Colors"
metadata borderColor.default is "166,166,166"

----------------------------------------------------------------


/**
Syntax: set the itemArray of <widget> to <array>
Syntax: get the itemArray of <widget>

Summary: The full navigation item data.

Value(array): An array containing all the navigation data.

Description:
The <itemArray> is a numerically keyed array.  Each element of the
array contains an array describing the name, label and icons of the
navigation item at that index.

The <itemArray> can be used to access and modify all of the navigation
data at once, rather than setting the <itemNames>, <itemLabels>,
<itemIcons> and <hilitedItemIcons> individually.

The structure of the <itemArray> is:

```
{ key (integer): The index of the navigation item
	value (array): The array containing the data for the item at this index
	{ key : "label"
		value (string): The label of this item
		key : "name"
		value (string): The name of this item
		key : "icon_name"
		value (string) : The name of the icon to display when the item is not highlighted
		key : "hilited_icon_name"
		value (string) : The name of the icon to display when the item is highlighted
		key : "manual_path"
		value (string) : Used to manually assign a path where the name lookup is not used
		key : "manual_hilited_path"
		value (string) : Used to manually assign a path where the name lookup is not used
	}
}
```

Any individual keys ("label", "icon_name", "hilited_icon_name") missing when
setting the <itemArray> will be added, and set to their defaults - "circle" for
the icons, and "New Item" for the label.

**Note:** When setting the <itemArray>, an error will be thrown if the
new value is not a numerically-keyed array.

**Note:** If you set both an *icon_name* or *hilited_icon_name* AND an *icon*
or *hilited_icon* (which are paths), the navRAD will overwrite the paths with
the ones it obtains by looking up the names. To force the widget to use a path,
populate the *manual_path* and the *manual_hilited_path*.

Related: hilitedItemIcons(property), itemIcons(property),
itemLabels(property), itemNames(property)

*/
property itemArray get getNavData set setNavData
metadata itemArray.editor is "com.livecode.pi.navbar"
metadata itemArray.label is "Navigation data"

/**
Syntax: set the itemNames of <widget> to <names>
Syntax: get the itemNames of <widget>
Summary: The names of the navigation items

Value(string): A comma-delimited list of navigation item names.

Description:
The names of the navigation items of the widget.  These are the names
used internally to identify each navigation item, rather than the
<itemLabels> displayed to the user.

Setting the <itemNames> can add or remove items to the navigation rad.

If the new value of the <itemNames> has more items than the navigation
rad, as many new navigation items as necessary are created and added
to the end of the navigation rad, using the default label and icons.

If the new value of the <itemNames> has fewer items than the
navigation rad, items are removed from the end of the navigation rad
as required.

It is not possible to re-order the navigation items by setting the
<itemNames>.

References: itemLabels(property)
*/
property itemNames		get getNavNames			set setNavNames
metadata itemNames.editor is "com.livecode.pi.editorList"
metadata itemNames.subeditor is "com.livecode.pi.string"
metadata itemNames.delimiter is ","
metadata itemNames.label is "Navigation names"

/**
Syntax: set the itemIcons of <widget> to <icons>
Syntax: get the itemIcons of <widget>
Summary: The normal-state icons for the navigation items

Value(string): A comma-delimited list of icon names.

Description:
The names of the icons displayed by the navigation items when not
highlighted.

Each icon name must be one of the predefined graphics provided by the "IconSVG"
library.  You can get a list of available predefined path names by running
`put iconNames()` in the Message Box.

Setting the <itemIcons> can add items to the navigation rad.  If the
new value of the <itemIcons> has more items than the navigation ,
as many new navigation items as necessary are created and added to the
end of the navigation rad, using a default <itemNames|name>,
<itemLabels|label> and <hilitedItemIcons|highlighted icon>.

If the new value of the <itemIcons> has fewer items than the
navigation rad, the remaining navigation items have their icons reset
to the default icon.

References: hilitedItemIcons(property), itemLabels(property),
itemNames(property)

*/
property itemIcons		get getNavIcons			set setNavIcons
metadata itemIcons.user_visible is "false"

/**
Syntax: set the hilitedItemIcons of <widget> to <icons>
Syntax: get the hilitedItemIcons of <widget>
Summary: The highlighted-state icons for the navigation icons

Value(string): A comma-delimited list of icon names.

Description:
The names of the icons displayed by the navigation items when
highlighted.

Each icon name must be one of the predefined graphics provided by the "IconSVG"
library.  You can get a list of available predefined path names by running
`put iconNames()` in the Message Box.

Setting the <hilitedItemIcons> can add items to the navigation rad.
If the new value of the <hilitedItemIcons> has more items than the
navigation rad, as many new navigation items as necessary are created
and added to the end of the navigation rad, using a default
<itemNames|name>, <itemLabels|label> and <itemIcons|normal icon>.

If the new value of the <hilitedItemIcons> has fewer items than the
navigation rad, the remaining navigation items have their
highlighted-state icons reset to the default icon.

References: itemIcons(property), itemLabels(property), itemNames(property)
*/
property hilitedItemIcons		get getNavSelectedIcons			set setNavSelectedIcons
metadata hilitedItemIcons.user_visible is "false"

/**
Syntax: set the itemLabels of <widget> to <labels>
Syntax: get the itemLabels of <widget>
Summary: The labels of the navigation items

Value(string): A comma-delimited list of labels.

Description:
The display labels for the navigation items of the widget.

Setting the <itemLabels> can add items to the navigation rad.  If the
new value of the <itemLabels> has more items than the navigation rad,
as many new navigation items as necessary are created and added to the
end of the navigation rad, using a default <itemNames|name>,
<itemIcons|icon> and <hilitedItemIcons|highlighted icon>.

If the new value of the <itemLabels> has fewer items than the
navigation rad, the remaining navigation items have their labels reset
to the default icon.

References: hilitedItemIcons (property), itemIcons (property),
itemNames(property)
*/
property itemLabels		get getNavLabels		set setNavLabels
metadata itemLabels.user_visible is "false"

/**
Syntax: set the itemStyle of <widget> to <style>
Syntax: get the itemStyle of <widget>

Summary: The style with which navigation items are displayed

Value(enum): The display style
- "icons": display icons only
- "text": display names only
- "both": display icons and names

Description:
The <itemStyle> property determines whether navigation items are
displayed with icons, with labels, or with icons positioned below
labels.

Related: hilitedItemIcons (property), itemIcons (property),
itemLabels(property)
*/
property itemStyle	get mItemStyle	set setItemStyle
metadata itemStyle.editor is "com.livecode.pi.enum"
metadata itemStyle.options is "icons,text,both"
metadata itemStyle.default is "both"
metadata itemStyle.label is "Display style"


/**
Syntax: set the hilitedItem of <widget> to <itemNumber>
Syntax: get the hilitedItem of <widget>

Summary: The index of the highlighted navigation item

Value(integer): The item number of the navigation item that is highlighted.

Description:
The <hilitedItem> is the item number of the currently-highlighted navigation
item, starting from 1.  It can be used as a key into the <itemArray>.

Related: hilitedItemName (property), hiliteChanged (message)

References: itemArray(property)
*/
property hilitedItem	get mSelectedItem 	set setNavSelectedItem
metadata hilitedItem.editor is "com.livecode.pi.integer"
metadata hilitedItem.default is "1"
metadata hilitedItem.label is "Selected item index"
metadata hilitedItem.step is "1"
metadata hilitedItem.min is "0"

/**
Syntax: set the iconZoom of <widget> to (Zoom Percent)
Syntax: get the iconZoom of <widget>

Summary: Zoom in/out Icons

Value(integer): The percent to zoom icon (default 100)

Description:
When the Icon is generated this property will change
the icon size by this percent.

Related: IconFill (property)

References: itemArray(property)
*/
property iconZoom	get mIconZoom 	set setNavIconZoom
metadata iconZoom.editor is "com.livecode.pi.integer"
metadata iconZoom.label is "Icon Zoom %"
metadata iconZoom.step is "1"
metadata iconzoom.default is "100"
metadata iconZoom.max is "150"
metadata iconZoom.min is "50"

/**
Syntax: set the hilitedItemName of <widget> to <pName>
Syntax: get the hilitedItemName of <widget>

Summary: The name of the highlighted navigation item

Value(string): The name of the navigation item that is highlighted.

Description:
The <hilitedItemName> is the name of the currently-highlighted navigation
item.

References: hilitedItem (property), hiliteChanged (message)
*/

property hilitedItemName	get getNavSelectedItemName	set setNavSelectedItemName
metadata hilitedItemName.user_visible is "false"
/*
metadata hilitedItemName.label is "Selected item name"
*/

/**
Syntax: get the preHilitedItem of <widget>

Summary: The index of the preHighlighted navigation item

Value(integer): The item number of the navigation item selected but not yet highlighted.

Description:
The <preHilitedItem> is the item number of the currently clicked but not yet
highlighted item, starting from 1.  It can be used as a key into the <itemArray>.

Related: preHilitedItemName (property), preHiliteChanged (message)

References: itemArray(property)
*/
property preHilitedItem		get getPreNavSelectedItem set setPreNavSelectedItem
metadata preHilitedItem.user_visible is "false"

/**
Syntax: get the preHilitedItemName of <widget>

Summary: The name of the preHighlighted navigation item

Value(string): The name of the navigation item that is to be highlighted.

Description:
The <hilitedItemName> is the name of the currently clicked but not yet
highlighted item.

References: preHilitedItem (property), preHiliteChanged (message)
*/
property preHilitedItemName	get getPreNavSelectedItemName set setPreNavSelectedItemName
metadata preHilitedItemName.user_visible is "false"

/**
Syntax: set the editMode of <widget> to {true | false}
Syntax: get the editMode of <widget>

Summary: Whether the widget is in edit mode

Description:
**Note:** This feature is currently **experimental** and may change or
be removed in future versions.

When the <editMode> is enabled, the navigation items' icons can be
changed by clicking on the outlined regions, and new items can be added
with the add button.
*/
property editMode get mEditMode set setEditMode
metadata editMode.user_visible is "false"

/**
Syntax: get the desiredHeight of <widget>

Summary: The optimal height for the widget

Example:
create widget as "com.livecode.widget.navrad"
set the height of it to the desiredHeight of it

Description:
**Note:** This feature is currently **experimental** and may change or
be removed in future versions.

Returns the preferred height for widget, calculated from its current
state.
*/
property desiredHeight	get getDesiredHeight
metadata desiredHeight.user_visible is "false"

/**
Syntax: set the showBorder of <widget> to {true | false}
Syntax: get the showBorder of <widget>

Summary: Whether there is a dividing line at the top of the widget

Description:
When the <showBorder> property is `true`, the navigation rad has a
dividing line along its top edge.

Related: borderColor(property)
*/
property showBorder get mShowDivide set setShowDivide
metadata showBorder.default is "true"
metadata showBorder.label is "Show border"


--property "noDefault" get mNoDefault set setNoDefault
--metadata noDefault.default is "false"
--metadata noDefault.label is "No Default"

-- RAD Change add the new iconFill Property with documentation
/**
Syntax: set the iconFill of <widget> to {true | false}
Syntax: get the iconFill of <widget>

Summary: Whether there the icon is centered with an empty label

Description:
When the <iconFill> property is `true`(default is false),
the icon is Vertically centered if there is no label.
Also a blank label does not autofill with "New Item".

Related: itemLabels(property)
*/

property "iconFill" get mIconFill set setIconFill
metadata iconFill.default is "false"
metadata iconFill.label is "Icon Fill"

-- RAD Change add the new autoRADHilite Property with documentation
/**
Syntax: set the autoRADHilite of <widget> to {true | false}

Summary: Whether the selected(clicked) icon/label are hilited.

Example:
on preHiliteChanged
   answer "Pre hilite. Do it?" with "Yes" and "No"
   if it = "Yes" then
      set the hiliteditem of the target to the hiliteditem of the target
   end if
end preHiliteChanged

Description:
When the <autoRADHilite> property(Auto Hilite in property inspector)
is `true`(default):
When the selected icon/label is clicked the icon is not
hiilited. The hiliteChanged message is not sent.
You can make the descision to continue or not.
If you want to continue and have the hiliteChanged message
sent then, set the hiliteditem to the preHiliteditem.
existing hiliteditem handler requires no changes.

Related: itemLabels(property)
*/

property "autoRADHilite" get mAutoRADHilite set setAutoRADHilite
metadata autoRADHilite.default is "true"
metadata autoRADHilite.label is "Auto Hilite"

/**
Name: opaque

Syntax: set the opaque of <widget> to {true | false}
Syntax: get the opaque of <widget>

Summary: Whether the background of the widget is filled

Description:
If the <opaque> property is `true`, the background of the navigation
rad is filled with the <backColor>.  If it is `false` the background
is transparent.

Related: preHilitedItem(property), preHilitedItemName(property)
hilitedItem(property), hilitedItemName(property),
hiliteChanged(message)

*/

property "opaque" get mShowBackground set setShowBackground
metadata opaque.default is "true"
metadata opaque.label is "Opaque background"

metadata textSize.default is "10"



/**
Name: leftMargin

Syntax: set the leftMargin of <widget> to integer
Syntax: get the leftMargin of <widget>

Summary: Specifies how close text within an object can come to the NavRAD's left edge

Description:
Use the leftMargin property to change the amount of blank space between the navRAD's left edge and its contents.
The leftMargin property is equal to item 1 of its margins property.

*/
property "leftMargin" get getLeftMargin set setLeftMargin
metadata leftMargin.default is "0"
metadata leftMargin.editor is "com.livecode.pi.integer"
metadata leftMargin.label is "Left Margin"
metadata leftMargin.step is "1"
metadata leftMargin.min is "0"



/**
Name: topMargin

Syntax: set the topMargin of <widget> to integer
Syntax: get the topMargin of <widget>

Summary: Specifies how close text within an object can come to the NavRADs top edge

Description:
Use the topMargin property to change the amount of blank space between the navRAD's top edge and its contents.
The topMargin property is equal to item 2 of its margins property.
*/

property "topMargin" get getTopMargin set setTopMargin
metadata topMargin.default is "0"
metadata topMargin.editor is "com.livecode.pi.integer"
metadata topMargin.label is "Top Margin"
metadata topMargin.step is "1"
metadata topMargin.min is "0"



/**
Name: rightMargin

Syntax: set the rightMargin of <widget> to integer
Syntax: get the rightMargin of <widget>

Summary: Specifies how close text within an object can come to the NavRAD's right edge

Description:
Use the rightMargin property to change the amount of blank space between an NavRAD's right edge and its contents.
The rightMargin property is equal to item 3 of its margins property.

*/
property "rightMargin" get getRightMargin set setRightMargin
metadata rightMargin.default is "0"
metadata rightMargin.editor is "com.livecode.pi.integer"
metadata rightMargin.label is "Right Margin"
metadata rightMargin.step is "1"
metadata rightMargin.min is "0"


/**
Name: bottomMargin

Syntax: set the bottomMargin of <widget> to integer
Syntax: get the bottomMargin of <widget>

Summary: Specifies how close text within an object can come to the NavRAD''s bottom edge

Description:
Use the bottomMargin property to change the amount of blank space between an NavRADs bottom edge and its contents.
The bottomMargin property of a field is equal to item 4 of its margins property.

*/
property "bottomMargin" get getBottomMargin set setBottomMargin
metadata bottomMargin.default is "0"
metadata bottomMargin.editor is "com.livecode.pi.integer"
metadata bottomMargin.label is "Bottom Margin"
metadata bottomMargin.step is "1"
metadata bottomMargin.min is "0"



/**
Name: margins

Syntax: set the margins of <widget> to integer
Syntax: get the margins of <widget>

Summary: Specifies how much empty space is left on each side between a NavRAD's edges and its contents.

Description:
Use the margins property to control how close text within a button or field can come to the NavRAD's edges.

If a single integer is specified, all four margins of the object are set to that number of pixels. If four integers are provided, the object's top, left, bottom, and right margins are set to each one respectively:

item 1 of the margins property is equal to the leftMargin
item 2 of the margins is equal to the topMargin
item 3 is equal to the rightMargin
item 4 is equal to the bottomMargin

*/
property "margins" get getMargins set setMargins
metadata margins.default is "0,0,0,0"
metadata margins.user_visible is "false"


/**
Name: traditionalMargins

Syntax: set the traditionalMargins of <widget> to boolean
Syntax: get the traditionalMargins of <widget>

Summary: Specifies how the left and right margins of the NavRAD will be applied (defaults to true)

Description:
Traditional margins (option "true") margins apply both left and right margins to all items in the NavRAD.
Non-traditional margins (option "false") only apply the left margin to the leftmost item and the right
margin to the rightmost column. This may be useful when the device's screen furniture covers part of the
NavRAD.
*/

property traditionalMargins get mTraditionalMargins set setTraditionalMargins
metadata traditionalMargins.user_visible is "false"
metadata traditionalMargins.default is "true"




--

-- private instance variables
private variable mNavData as List

private variable mPreSelectedItem as Integer
private variable mPreSelectedItemName as String

private variable mSelectedItem as Integer
private variable mIconZoom as Integer
private variable mItemStyle as String

private variable mNavItemCount as Integer
private variable mBoxWidth as Real

private variable mWidth as Real
private variable mHeight as Real

private variable mRecalculate as Boolean

private variable mEditMode as Boolean
private variable mAddIcon as Path
private variable mDeleteIcon as Path
private variable mReorderIcon as Path

private variable mDragData as optional Array

private variable mHiliteColor as Color

private variable mShowDivide as Boolean
private variable mShowBackground as Boolean
--private variable mNoDefault as Boolean

--RAD Change add var for iconFill
private variable mIconFill as Boolean

--RAD Change add var for autoRADHilite
private variable mAutoRADHilite as Boolean

private variable mActionPaths as Array

private variable mMargins as List

private variable mTraditionalMargins as Boolean

--

constant kIconPaddingRatio is 0.1225
constant kLabelPaddingRatio is 0.06
constant kLabelHeightRatio is 0.165

constant kEditModePaddingUnit is 10
constant kEditModeLineHeight is 50

constant kIconOnlyPaddingRatio is 0.2

constant kDefaultNavName is "new item"
constant kDefaultNavLabel is "New Item"
constant kDefaultNavIconName is "circle"



public handler OnSave(out rProperties as Array)
	put the empty array into rProperties

	put getNavData() into rProperties["items"]
	put mSelectedItem into rProperties["selected"]
	put mIconZoom into rProperties["iconZoom"]
	put mItemStyle into rProperties["itemStyle"]
	put mShowDivide into rProperties["showBorder"]
	--put mNoDefault into rProperties["noDefault"]
	-- RAD Change Save the iconFill property
	put mIconFill into rProperties["iconFill"]
	-- RAD Change Save the autoRADHilite property
	put mAutoRADHilite into rProperties["autoRADHilite"]
	put mShowBackground into rProperties["opaque"]
	put getMargins() into rProperties["margins"]
	put mTraditionalMargins into rProperties["traditionalMargins"]
end handler



public handler OnLoad(in pProperties as Array)
	setNavData(pProperties["items"])
	put pProperties["selected"] into mSelectedItem
	
	if "iconZoom" is among the keys of pProperties then
		put pProperties["iconZoom"] into mIconZoom
	else
		put 100 into mIconZoom
	end if 

	setItemStyle(pProperties["itemStyle"])

	if "showBorder" is among the keys of pProperties then
		put pProperties["showBorder"] into mShowDivide
	else
		put true into mShowDivide
	end if

	--if "noDefault" is among the keys of pProperties then
		--put pProperties["noDefault"] into mNoDefault
	--else
		--put true into mNoDefault
	--end if
	-- RAD Change Init iconFill  Question: when does load happen?
	if "iconFill" is among the keys of pProperties then
		put pProperties["iconFill"] into mIconFill
	else
		put true into mIconFill
	end if

	-- RAD Change Init autoRADHilite  Question: when does load happen?
	if "autoRADHilite" is among the keys of pProperties then
		put pProperties["autoRADHilite"] into mAutoRADHilite
	else
		put true into mAutoRADHilite
	end if

	if "opaque" is among the keys of pProperties then
		put pProperties["opaque"] into mShowBackground
	else
		put true into mShowBackground
	end if

	variable tMargins as List
	if "margins" is among the keys of pProperties then
		split pProperties["margins"] by "," into tMargins
		parse tMargins as list of number into mMargins
		if mMargins is nothing then
			put [0,0,0,0] into mMargins
		end if
	else
		put [0,0,0,0] into mMargins
	end if

	variable setTraditionalMargins as Boolean
	if "traditionalMargins" is among the keys of pProperties then
		put pProperties["traditionalMargins"] into mTraditionalMargins
	else
		put true into mTraditionalMargins
	end if
end handler



public handler OnCreate() returns nothing
	-- creating a list of navigation items

	variable tNavItems as List
	put the empty list into tNavItems

	variable tArray as Array
	put the empty array into tArray

	put "contacts" into tArray["name"]
	put "Contacts" into tArray["label"]
	put "user" into tArray["icon_name"]
	put "" into tArray["hilited_icon_name"]
	put "" into tArray["icon"]
	put "" into tArray["hilited_icon"]
	put "" into tArray["manual_path"]
	put "" into tArray["manual_hilited_path"]
	push tArray onto tNavItems

	put "favourites" into tArray["name"]
	put "Favourites" into tArray["label"]
	put "star empty" into tArray["icon_name"]
	put "" into tArray["hilited_icon_name"]
	put "" into tArray["icon"]
	put "" into tArray["hilited_icon"]
	put "" into tArray["manual_path"]
	put "" into tArray["manual_hilited_path"]

	push tArray onto tNavItems

	put "music" into tArray["name"]
	put "Music" into tArray["label"]
	put "music" into tArray["icon_name"]
	put "" into tArray["hilited_icon_name"]
	put "" into tArray["icon"]
	put "" into tArray["hilited_icon"]
	put "" into tArray["manual_path"]
	put "" into tArray["manual_hilited_path"]

	push tArray onto tNavItems

	put "search" into tArray["name"]
	put "Search" into tArray["label"]
	put "search" into tArray["icon_name"]
	put "" into tArray["hilited_icon_name"]
	put "" into tArray["icon"]
	put "" into tArray["hilited_icon"]
	put "" into tArray["manual_path"]
	put "" into tArray["manual_hilited_path"]
	push tArray onto tNavItems
	put the number of elements in tNavItems into mNavItemCount

	put tNavItems into mNavData

	put 1 into mSelectedItem
	put 100 into mIconZoom
	put nothing into mDragData
	put "both" into mItemStyle

	put 0 into mPreSelectedItem
	put "" into mPreSelectedItemName

	put 0 into mBoxWidth

	initialiseEditData()

	put true into mRecalculate
	put false into mEditMode

	put path iconSVGPathFromName("plus") into mAddIcon
	put path iconSVGPathFromName("minus sign") into mDeleteIcon
	put path iconSVGPathFromName("reorder") into mReorderIcon

	put color [0, 121/255,1] into mHiliteColor

	put true into mShowDivide
	put true into mShowBackground

	put the empty array into mActionPaths

	put [0,0,0,0] into mMargins

	put true into mTraditionalMargins
end handler



public handler OnPaint() returns nothing
	if mRecalculate then
		updateParameters()
	end if

	if not mEditMode then
		drawNavRad()
	else
		drawNavRadEditMode()
	end if
end handler

----------------------------------------------------------------
-- Drawing in normal mode
----------------------------------------------------------------

private handler drawNavRad() returns nothing
	-- background
	if mShowBackground then
		set the paint of this canvas to my background paint
		fill getPath("background") on this canvas
	end if

	if mNavItemCount is not 0 then
		drawNavRadContent()
	end if

	-- Draw the top line
	if mShowDivide then
		set the paint of this canvas to my border paint
		set the stroke width of this canvas to 0
		stroke getPath("line") on this canvas
	end if
end handler



private handler drawNavRadContent() returns nothing
	variable tX as Integer
	repeat with tX from 1 up to mNavItemCount
		-- Draw the text of the nav rad
		if mItemStyle is in ["text","both"] then
			drawLabel(mNavData[tX]["label"], mNavData[tX]["label_rect"], tX is mSelectedItem)
		end if

		if mItemStyle is in ["icons","both"] then
			-- Draw the icon
			if tX is mSelectedItem then
				drawIcon(mNavData[tX]["hilited_icon_path"], true)
			else
				drawIcon(mNavData[tX]["icon_path"], false)
			end if

		end if
	end repeat
end handler

----------------------------------------------------------------
-- Drawing in edit mode
----------------------------------------------------------------

private handler drawNavRadEditMode() returns nothing
	// Make sure the subsequent drawing operations are opaque
	set the opacity of this canvas to 1
	// background
	set the paint of this canvas to getPaint("background","editmode-fill")
	fill getPath("bounding box") on this canvas

	set the paint of this canvas to getPaint("background","editmode-stroke")
	set the stroke width of this canvas to 0
	stroke getPath("bounding box") on this canvas

	if mNavItemCount is 0 then
		set the paint of this canvas to getPaint("add", "fill")
		fill mActionPaths["add_icon_path"] on this canvas
	else
		drawEditModeContent()
	end if
end handler



private handler drawEditModeContent() returns nothing
	variable tX as Integer
	repeat with tX from 1 up to mNavItemCount
		-- Draw the text of the nav rad
		drawEditModeLabel(mNavData[tX]["label"], mNavData[tX]["label_rect"])
		-- Draw the icon
		drawIcon(mNavData[tX]["icon_path"], false)
		-- Draw the selectedIcon
		drawIcon(mNavData[tX]["hilited_icon_path"], true)
		-- Draw the 'add item' item
		drawActionItems(tX)
		-- Draw the rects round the editable elements
		--drawEditableRects(this canvas)
		-- Draw the line between items
		drawEditModeDivide(tX)
	end repeat

	if mDragData is not nothing then
		drawDragData()
	end if
end handler



	private handler drawDragData()
		if mDragData is nothing then
			return
		end if

		variable tTargetPath as Path
		if "target" is among the keys of mDragData then
			if mDragData["target"] is 0 then
				put line path from point [0, mDragData["target"] * kEditModeLineHeight + 2] to point [mWidth, mDragData["target"] * kEditModeLineHeight + 2] into tTargetPath
			else if mDragData["target"] is mNavItemCount then
				put line path from point [0, mDragData["target"] * kEditModeLineHeight - 2] to point [mWidth, mDragData["target"] * kEditModeLineHeight - 2] into tTargetPath
			else
				put line path from point [0, mDragData["target"] * kEditModeLineHeight] to point [mWidth, mDragData["target"] * kEditModeLineHeight] into tTargetPath
			end if

			set the paint of this canvas to getPaint("text", "selected-fill")
			set the stroke width of this canvas to 3
			stroke tTargetPath on this canvas
		end if

		if "rect" is among the keys of mDragData then
			set the opacity of this canvas to 0.4
			set the paint of this canvas to getPaint("background","drag-fill")
			fill rectangle path of mDragData["rect"] on this canvas
		-- Draw the text of the nav rad
		drawEditModeLabel(mDragData["label"], mDragData["label_rect"])
		-- Draw the icon
		drawIcon(mDragData["icon_path"], false)
		-- Draw the selectedIcon
		drawIcon(mDragData["hilited_icon_path"], true)
	end if
end handler --drawDragData



private handler drawEditModeDivide(in pNumber as Number) returns nothing
	if pNumber is mNavItemCount then
		return
	end if
	variable tPath as Path
	put line path from point [1, kEditModeLineHeight * pNumber] to point [mWidth - 1, kEditModeLineHeight * pNumber + 1] into tPath
	set the paint of this canvas to my border paint
	set the stroke width of this canvas to 0
	stroke tPath on this canvas
end handler



private handler drawIcon(in pIconPath as Path, in pSelected as Boolean)
	if pSelected then
		set the paint of this canvas to my highlight paint
	else
		set the paint of this canvas to my foreground paint
	end if

	fill pIconPath on this canvas
end handler



private handler drawLabel(in pLabel as String, in pRect as Rectangle, in pSelected as Boolean)
	if pSelected then
		set the paint of this canvas to my highlight paint
	else
		set the paint of this canvas to my foreground paint
	end if

	set the font of this canvas to getFont("label")
	fill text pLabel at center of pRect on this canvas
end handler



private handler drawEditModeLabel(in pLabel as String, in pRect as Rectangle)
	set the paint of this canvas to getPaint("text","editmode-fill")
	set the font of this canvas to getFont("editmode-label")
	fill text pLabel at left of pRect on this canvas
end handler



constant kStandardActions is ["add","delete","reorder"]
private handler drawActionItems(in pRow as Integer)
	drawActionItemsList(kStandardActions, pRow)
end handler



private handler drawActionItemsList(in pActions as List, in pRow as Integer)
	variable tIconPath as Path
	variable tElement as String
	repeat for each element tElement in pActions
		-- Draw the item
		set the paint of this canvas to getPaint(tElement, "fill")
		put mNavData[pRow][tElement & "_icon_path"] into tIconPath
		fill tIconPath on this canvas
	end repeat
end handler



public handler OnMouseUp() returns nothing
	variable tClickPos as Point
	put the click position into tClickPos
	if mEditMode then
		-- Dismiss the transient fields when the widget is clicked
		post "dismissTransient"
		widgetClicked(tClickPos, true)
	end if
end handler



public handler OnMouseDown() returns nothing
	variable tClickPos as Point
	put the click position into tClickPos
	if mEditMode then
		widgetClicked(tClickPos, false)
	else
		variable tSelected as Number
		put locToNavItem(tClickPos) into tSelected

		if tSelected >= 0 then
			--put tSelected into mSelectedItem
			-- RAD Change If orig then set the selected item
			if mAutoRADHilite then
				put tSelected into mSelectedItem
				redraw all
			end if
			variable tItemLabel as String
			if tSelected > 0 then
				put mNavData[mSelectedItem]["label"] into tItemLabel
			else
				put nothing into tItemLabel
			end if
			-- RAD Change here to send preHiliteChanged message
			if mAutoRADHilite then
				post "hiliteChanged"
			else
				if mSelectedItem is not tSelected then
					put tSelected into mPreSelectedItem
					put mNavData[tSelected]["label"] into mPreSelectedItemName
					post "preHiliteChanged"
				end if
			end if
		end if
	end if
end handler



public handler OnMouseMove() returns nothing
	if mDragData is not nothing then
		calculateDragRow(the y of the mouse position)
		redraw all
		return
	end if

	if mEditMode then
		updateEditModeTooltip(the mouse position)
		return
	end if
end handler



private handler updateParameters()
	initialiseEditData()

	// update variables
	put my width into mWidth
	put my height into mHeight
	put the number of elements in mNavData into mNavItemCount

	if mNavItemCount is 0 then
		put mWidth into mBoxWidth
	else
		put mWidth / mNavItemCount into mBoxWidth
	end if

	if mEditMode then
		if mNavItemCount is 0 then
			calculateAddItemRect()
		else
			calculateEditModeIconRects()
		end if
	else if mNavItemCount is not 0 then
		calculateIconRects()
	end if
	put false into mRecalculate
end handler



private handler updateEditModeTooltip(in pPosition as Point) returns nothing
	variable tElement as Array
	repeat for each element tElement in mEditData
	if pPosition is within tElement["rect"] then
		if "tooltip" is among the keys of tElement then
			set property "tooltip" of my script object to tElement["tooltip"]
			return
		end if
	end if
end repeat

set property "tooltip" of my script object to ""
end handler



private handler calculateEditModeIconRects() returns nothing
	// calculate the drawing rects
	variable tX as Integer
	variable tIconPath as Path
	variable tIconRect as Rectangle
	variable tLineHeight as Real
	put kEditModeLineHeight into tLineHeight

	repeat with tX from 1 up to mNavItemCount
	variable tLabelLeft as Real
	variable tLabelRight as Real

	variable tLineTop as Real
	variable tLineBottom as Real
	put (tX - 1) * tLineHeight into tLineTop
	put tX * tLineHeight into tLineBottom

		-- One 1/2 line height icon + 2 lots of padding gives width of data to left of label
		put 2 * kEditModePaddingUnit + tLineHeight / 4 into tLabelLeft
		-- Two 1/4 line height icons + two line height icons + 4 lots of padding gives width of data to right of label
		put mWidth - (4 * kEditModePaddingUnit + 5 * tLineHeight / 2) into tLabelRight

		put rectangle [tLabelLeft, tLineTop + kEditModePaddingUnit, tLabelRight, tLineBottom - kEditModePaddingUnit] into mNavData[tX]["label_rect"]
		-- Allow label to be edited inline
		setEditableTextRect("label", tX, mNavData[tX]["label_rect"], "Label")

		if mNavData[tX]["icon_name"] is not empty then
			put iconSVGPathFromName(mNavData[tX]["icon_name"]) into mNavData[tX]["icon"]
		end if
		put path mNavData[tX]["icon"] into tIconPath

		variable tLeft as Real
		put tLabelRight + kEditModePaddingUnit into tLeft

		put rectangle [tLeft + kEditModePaddingUnit, tLineTop + kEditModePaddingUnit, tLeft + tLineHeight - kEditModePaddingUnit, tLineBottom - kEditModePaddingUnit] into tIconRect

		constrainPathToRect(tIconRect, tIconPath)
		put tIconPath into mNavData[tX]["icon_path"]
		put tIconRect into mNavData[tX]["icon_rect"]

		if mNavData[tX]["hilited_icon_name"] is not empty then
			put iconSVGPathFromName(mNavData[tX]["hilited_icon_name"]) into mNavData[tX]["hilited_icon"]
		end if

		if mNavData[tX]["hilited_icon"] is not "" then
			put path mNavData[tX]["hilited_icon"] into tIconPath
		end if

		add tLineHeight to tLeft
		put rectangle [tLeft + kEditModePaddingUnit, tLineTop + kEditModePaddingUnit, tLeft + tLineHeight - kEditModePaddingUnit, tLineBottom - kEditModePaddingUnit] into tIconRect
		constrainPathToRect(tIconRect, tIconPath)
		put tIconPath into mNavData[tX]["hilited_icon_path"]
		put tIconRect into mNavData[tX]["hilited_icon_rect"]

		setEditableRect("icon", tX, mNavData[tX]["icon_rect"], \
			"Icon", "com.livecode.widget.iconPicker", iconSelected)
		setEditableRect("selectedIcon", tX, mNavData[tX]["hilited_icon_rect"], \
			"Highlighted Icon", "com.livecode.widget.iconPicker", iconSelected)

		calculateEditModeActionPathsForRow(tX)
	end repeat
end handler --calculateEditModeIconRects



private handler calculateAddItemRect()
	calculateEditModeActionIconPaths(["add"])
	setActionRect("add_icon", 1, \
		the bounding box of mActionPaths["add_icon_path"], "Add Item", \
		addItem, true)
end handler



private handler calculateEditModeActionPathsForRow(in pRow as Integer)
	calculateEditModeActionIconPaths(kStandardActions)

	variable tIconPath as Path
	put mActionPaths["add_icon_path"] into tIconPath
	translate tIconPath by [0, (pRow - 1) * kEditModeLineHeight]
	put tIconPath into mNavData[pRow]["add_icon_path"]
	setActionRect("add_icon", pRow, the bounding box of tIconPath, \
		"Add Item", addItem, true)

	put mActionPaths["delete_icon_path"] into tIconPath
	translate tIconPath by [0, (pRow - 1) * kEditModeLineHeight]
	put tIconPath into mNavData[pRow]["delete_icon_path"]
	setActionRect("delete_icon", pRow, the bounding box of tIconPath, \
		"Delete Item", deleteItem, true)

	put mActionPaths["reorder_icon_path"] into tIconPath
	translate tIconPath by [0, (pRow - 1) * kEditModeLineHeight]
	put tIconPath into mNavData[pRow]["reorder_icon_path"]
	setActionRect("reorder_icon", pRow, the bounding box of tIconPath, \
		"Reposition Item", reorderItem, false)

end handler



private handler calculateEditModeActionIconPaths(in pActions as List)
	variable tIconPath as Path
	variable tIconRect as Rectangle

	variable tActionFraction as Real
	put 1/4 into tActionFraction

	variable tLeft as Real
	variable tTop as Real
	variable tRight as Real
	variable tBottom as Real
	put my width - 2 * (kEditModeLineHeight * tActionFraction + kEditModePaddingUnit) into tLeft
	put kEditModeLineHeight * (1 - tActionFraction) / 2 into tTop
	put tLeft + kEditModeLineHeight * tActionFraction into tRight
	put kEditModeLineHeight - kEditModeLineHeight * (1 - tActionFraction) / 2 into tBottom

	if "add" is in pActions then
		put rectangle [tLeft, tTop, tRight, tBottom] into tIconRect
		put mAddIcon into tIconPath
		constrainPathToRect(tIconRect, tIconPath)
		put tIconPath into mActionPaths["add_icon_path"]
	end if

	if "reorder" is in pActions then
		add kEditModeLineHeight * tActionFraction + kEditModePaddingUnit to tLeft
		put tLeft + kEditModeLineHeight * tActionFraction into tRight
		put rectangle [tLeft, tTop, tRight, tBottom] into tIconRect
		put mReorderIcon into tIconPath
		constrainPathToRect(tIconRect, tIconPath)
		put tIconPath into mActionPaths["reorder_icon_path"]
	end if

	if "delete" is in pActions then
		put rectangle [kEditModePaddingUnit, tTop, kEditModePaddingUnit + kEditModeLineHeight * tActionFraction, tBottom] into tIconRect
		put mDeleteIcon into tIconPath
		constrainPathToRect(tIconRect, tIconPath)
		put tIconPath into mActionPaths["delete_icon_path"]
	end if
end handler



private handler calculateDragRow(in pY as Real) returns nothing
	variable tLineHeight as Real
	put kEditModeLineHeight into tLineHeight

	-- calculate the drag destination
	put the floor of ((pY + tLineHeight / 2) / tLineHeight) into mDragData["target"]

	variable tLabelLeft as Real
	variable tLabelRight as Real

	variable tLineTop as Real
	variable tLineBottom as Real
	put pY - mDragData["offset"] into tLineTop
	put tLineTop + tLineHeight  into tLineBottom

	-- calculate the drawing rects
	put rectangle [0, tLineTop, mWidth, tLineBottom] into mDragData["rect"]

	-- One 1/2 line height icon + 2 lots of padding gives width of data to left of label
	put 2 * kEditModePaddingUnit + tLineHeight / 4 into tLabelLeft
	-- Two 1/4 line height icons + two line height icons + 4 lots of padding gives width of data to right of label
	put mWidth - (4 * kEditModePaddingUnit + 5 * tLineHeight / 2) into tLabelRight

	put rectangle [tLabelLeft, tLineTop + kEditModePaddingUnit, tLabelRight, tLineBottom - kEditModePaddingUnit] into mDragData["label_rect"]

	variable tIconPath as Path
	variable tIconRect as Rectangle
	put path mNavData[mDragData["item"]]["icon"] into tIconPath

	variable tLeft as Real
	put tLabelRight + kEditModePaddingUnit into tLeft

	put rectangle [tLeft + kEditModePaddingUnit, tLineTop + kEditModePaddingUnit, tLeft + tLineHeight - kEditModePaddingUnit, tLineBottom - kEditModePaddingUnit] into tIconRect
	constrainPathToRect(tIconRect, tIconPath)
	put tIconPath into mDragData["icon_path"]

	if mNavData[mDragData["item"]]["hilited_icon"] is not "" then
		put path mNavData[mDragData["item"]]["icon"] into tIconPath
	end if

	add tLineHeight to tLeft
	put rectangle [tLeft + kEditModePaddingUnit, tLineTop + kEditModePaddingUnit, tLeft + tLineHeight - kEditModePaddingUnit, tLineBottom - kEditModePaddingUnit] into tIconRect
	constrainPathToRect(tIconRect, tIconPath)
	put tIconPath into mDragData["hilited_icon_path"]
end handler -- calculateDragRow



private handler calculateIconRects() returns nothing
	variable tNumItems as Number
	variable tIdx as Number
	variable tXOffset as Number
	variable tYOffset as Number
	variable tIconName as String
	variable tIconPadding as Number
	variable tIconRectInfo as List
	variable tLabelRectInfo as List
	variable tIconRect as Rectangle
	variable tLabelRect as Rectangle
	variable tIconType as String
	variable tIconPath as Path
	variable tBoxWidth as Integer
	variable tTop as Integer
	variable tIconTop as Integer
	variable tLabelTop as Integer
	variable tBottom as Integer
	variable tMargin as Integer
	variable tEffectiveHeight as Integer

	put getTopMargin() into tTop
	put my height - getBottomMargin() into tBottom
	put tBottom - tTop into tEffectiveHeight


	put the number of elements in mNavData into tNumItems

	repeat with tIdx from 1 up to tNumItems
		-- Compute vertical centreline for text and icon

		put mBoxWidth * (tIdx - 0.5) into tXOffset
		put mBoxWidth into tBoxWidth

		-- <margin math>
			if ( tIdx is 1 ) or mTraditionalMargins then -- margin shift right
				put getLeftMargin() into tMargin
				add tMargin to tXOffset
				subtract tMargin from  tBoxWidth 
			end if -- ( tIdx is 1 ) or mTraditionalMargins
			if ( tIdx is tNumItems ) or mTraditionalMargins then -- margin shift left
				put getRightMargin() into tMargin
				subtract tMargin from tXOffset
				subtract tMargin from tBoxWidth
			end if -- ( tIdx is tNumItems ) or mTraditionalMargins
		-- </margin math>

		-- Compute label rect
		if mItemStyle is "text" then
			-- Each label's effective rect is the whole of the item's box
			put [tXOffset - tBoxWidth / 2, tTop, \
			tXOffset + tBoxWidth / 2, tBottom] into tLabelRectInfo

		else
			-- Each label is located below the corresponding icon
			put ( tEffectiveHeight * (1 - kLabelPaddingRatio - kLabelHeightRatio) ) + tTop into tLabelTop
			put [ tXOffset - tBoxWidth / 2, \
			tLabelTop , \
			tXOffset + tBoxWidth / 2, \
			tBottom ] into tLabelRectInfo
		end if

		put rectangle tLabelRectInfo into tLabelRect
		put tLabelRect into mNavData[tIdx]["label_rect"]

		if mItemStyle is "text" then
			-- Don't need to process icons
			next repeat
		end if

		-- Compute icon rect
		-- RAD Change to center/enlarge the icon if iconFill if true and then label is empty
		if mItemStyle is "icons" or (mNavData[tIdx]["label"] is empty and mIconFill) then
			-- Position icons along horizontal centreline
			put (tEffectiveHeight * kIconOnlyPaddingRatio) into tIconPadding
			put [tXOffset - (tBoxWidth/2), \
			tIconPadding + tTop, \
			tXOffset + (tBoxWidth/2), \
			the minimum of ( tEffectiveHeight - tIconPadding ) and tBottom] into tIconRectInfo
		else
			-- Position icons above text
			put (tEffectiveHeight * kIconPaddingRatio) into tIconPadding
			put [tXOffset - (TBoxWidth/2), \
			tIconPadding + tTop, \
			tXOffset + (tBoxWidth/2), \
			the top of tLabelRect - tIconPadding]  into tIconRectInfo
		end if

		put rectangle tIconRectInfo into tIconRect

		variable tWidthOrig as Number
		variable tHeightOrig as Number
		put the width of tIconRect into tWidthOrig
		put the height of tIconRect into tHeightOrig
		set the width of tIconRect to tWidthOrig * (mIconZoom/100)
		set the height of tIconRect to tHeightOrig * (mIconZoom/100)
		set the left of tIconRect to the left of tIconRect +  ((tWidthOrig - the width of tIconRect)/2)
		set the top of tIconRect to the top of tIconRect +  ((tHeightOrig - the height of tIconRect)/2)
		--RAD Change end of iconFill icon calculateIconRects

		-- Fit icons into the icon rect.  Repeat twice, once for the "normal"
		-- icon and once for the "hilited" icon.  Note that we carry the "normal"
		-- path round to become the "hilited" icon if there's no "hilited" icon
		-- specified.
		put the empty path into tIconPath
		repeat for each element tIconType in ["icon","hilited_icon"]
			-- Update icon path
			if mNavData[tIdx]["manual_path"] is not empty then
				put mNavData[tIdx]["manual_path"] into mNavData[tIdx][tIconType]
			else if mNavData[tIdx][tIconType & "_name"] is not empty then
				put iconSVGPathFromName(mNavData[tIdx][tIconType & "_name"]) \
				into mNavData[tIdx][tIconType]
			else
				put "" into mNavData[tIdx][tIconType]
			end if

			-- Fit the icon path to the icon rect
			if mNavData[tIdx][tIconType] is not empty then
				-- Fit icon path to Rectangle
				put path mNavData[tIdx][tIconType] into tIconPath
				constrainPathToRect(tIconRect, tIconPath)
			end if

			put tIconPath into mNavData[tIdx][tIconType & "_path"]
			put tIconRect into mNavData[tIdx][tIconType & "_rect"]
		end repeat --for each element tIconType in ["icon","hilited_icon"]
	end repeat --with tIdx from 1 up to tNumItems
end handler --calculateIconRects



public handler OnGeometryChanged()
	put true into mRecalculate
end handler



--Callback when an icon is selected from the icon picker widget
public handler iconSelected(in pSelectedIcon as optional any, in pType as String, in pNumber as Number)
	if pSelectedIcon is not nothing then
		if pType is "selectedIcon" then
			put pSelectedIcon into mNavData[pNumber]["hilited_icon_name"]
			put "" into mNavData[pNumber]["hilited_icon"]
		else
			put pSelectedIcon into mNavData[pNumber]["icon_name"]
			put "" into mNavData[pNumber]["icon"]
		end if

		-- If the selected icon is the same as the icon, just put empty into the selected icon name
		-- that way, when the icon is changed, the selected icon will change too.
		if mNavData[pNumber]["hilited_icon_name"] is mNavData[pNumber]["icon_name"] then
			put "" into mNavData[pNumber]["hilited_icon_name"]
			put "" into mNavData[pNumber]["hilited_icon"]
		end if
		post "dataChanged"
		put true into mRecalculate
		redraw all
	end if
end handler



private handler clickPosToComponent(in pClickPos as Point) returns Integer
	variable tX as Integer
	repeat with tX from 1 up to mNavItemCount
	variable tIconRect as Rectangle
	put mNavData[tX]["icon_rect"] into tIconRect
	if pClickPos is within tIconRect then
		return tX
	end if
end repeat

return 0
end handler



private handler locToNavItem(in pLoc as Point) returns Integer
	return the floor of (the x of pLoc / mBoxWidth) + 1
end handler



private handler yPosToLine(in pY as Number) returns Integer
	variable tLineHeight as Real
	put mHeight / mNavItemCount into tLineHeight
	return the floor of (pY / tLineHeight) + 1
end handler



public handler setHiliteColor(in pColor as String) returns nothing
	put stringToColor(pColor) into mHiliteColor
	redraw all
end handler



public handler getHiliteColor() returns String
	return colorToString(mHiliteColor, false)
end handler



public handler getPath(in pObject as String) returns Path
	variable tRect
	put my bounds into tRect
	if pObject is "bounding box" then
		return rectangle path of rectangle [the left of tRect + 0.5, the top of tRect + 0.5, the right of tRect - 0.5, the bottom of tRect - 0.5]
	else if pObject is "line" then
		return line path from point [0, 0.5] to point [my width, 0.5]
		-- Offset background by 1 from the top so that line is allowed to be transparent
	else if pObject is "background" then
		return rectangle path of rectangle [the left of tRect + 0.5, the top of tRect + 1, the right of tRect - 0.5, the bottom of tRect - 0.5]
	end if
end handler



public handler getPaint(pLocation, pType) returns Paint
	if pLocation is "background" then
		if pType is "drag-fill" then
			return solid paint with color [200/255, 200/255, 200/255]
		else if pType is "stroke" then
			return solid paint with color [0, 0, 0, 0.2]
		else if pType is "editmode-stroke" then
			return solid paint with color [193/255, 193/255, 193/255]
		else if pType is "editmode-fill" then
			return solid paint with color [1, 1, 1]
		end if
	else if pLocation is "text" then
		if pType is "fill" then
			return solid paint with color [146/255, 146/255, 146/255]
		else if pType is "selected-fill" then
			return solid paint with mHiliteColor
		else if pType is "additem" or pType is "deleteitem" then
			return solid paint with color [1, 1, 1]
		else if pType is "editmode-fill" then
			return solid paint with color [0, 0, 0]
		end if
	end if

	if pLocation is "add" then
		return solid paint with color [146/255, 146/255, 146/255]
	else if pLocation is "reorder" then
		return solid paint with color [146/255, 146/255, 146/255]
	else if pLocation is "delete" then
		return solid paint with color [240/255, 0, 0]
	end if

	return solid paint with color [1, 100/255, 200/255]
end handler



private handler getFont(in pType as String) returns Font
	return my font
end handler



public handler setNavSelectedItem(in pSelectedItem as Integer) returns nothing
	if pSelectedItem is not mSelectedItem and \
	pSelectedItem >= 0 and \
	pSelectedItem <= the number of elements in mNavData then
	put pSelectedItem into mSelectedItem
	if pSelectedItem > 0 then
		post "hiliteChanged"
	end if
	redraw all
end if
end handler



public handler getPreNavSelectedItemName() returns String
	return mPreSelectedItemName
end handler



public handler setPreNavSelectedItemName(in pName as String) returns nothing

end handler



public handler getPreNavSelectedItem() returns Integer
	return mPreSelectedItem
end handler



public handler setPreNavSelectedItem(in pName as String) returns nothing

end handler




public handler setNavSelectedItemName(in pName as String) returns nothing
	variable tCount as Integer
	variable tItem as Array

	-- Find the item index corresponding to pName and set it as the
	-- currently-highlighted item.

	repeat with tCount from 1 up to the number of elements in mNavData
	put mNavData[tCount] into tItem
	if tItem["name"] is pName then
		setNavSelectedItem(tCount)
		exit repeat
	end if
end repeat

end handler



public handler getNavSelectedItemName() returns String
	return mNavData[mSelectedItem]["name"]
end handler



public handler setItemStyle(in pItemStyle as String) returns nothing
	-- Cope with old-style item style property values
	if pItemStyle is "icons and names" then
		put "both" into pItemStyle
	end if
	if pItemStyle is "names" then
		put "text" into pItemStyle
	end if

	put pItemStyle into mItemStyle
	put true into mRecalculate
	redraw all
end handler



public handler setEditMode(in pEditMode as Boolean) returns nothing
	put pEditMode into mEditMode

	put true into mRecalculate
	redraw all
end handler

--------------------------------------------------------------------------------
--
--		Data utilities
--
--------------------------------------------------------------------------------

private handler listToArray(in pList as List) returns Array
	variable tCount
	variable tArray
	put the empty array into tArray

	variable tKey as String
	repeat with tCount from 1 up to the number of elements in pList
		put tCount formatted as string into tKey
		put defaultNavArray() into tArray[tKey]

		variable tAttribute as String
		repeat for each key tAttribute in tArray[tKey]
			put pList[tCount][tAttribute] into tArray[tKey][tAttribute]
		end repeat
	end repeat
	return tArray
end handler



private handler setData(in pArray as Array, in pKeys as List, out rList as List)
	-- Excessive hoop-jumping to work around the fact that keys of numerically keyed LCS array
	-- comes into LCB as strings, and therefore must be parsed as number to sort, then formatted back
	-- to be used as keys again. Because parse/format of integer doesn't currently roundtrip, we need to
	-- create a lookup from the original strings.
	variable tKey
	variable tOrder as List
	put the empty list into tOrder
	variable tLookup as Array
	put the empty array into tLookup
	variable tNumericKey as Number
	repeat for each key tKey in pArray
		put tKey parsed as number into tNumericKey
		push tNumericKey onto tOrder
		put tKey into tLookup[tNumericKey formatted as string]
	end repeat
	sort tOrder in ascending numeric order

	variable tOrderKey
	variable tElement as Array
	variable tList as List
	put the empty list into tList

	variable tOriginalKey as String
	repeat for each element tOrderKey in tOrder
		put the empty array into tElement
		repeat for each element tKey in pKeys
			put tLookup[tOrderKey formatted as string] into tOriginalKey
			-- Use default item if key is not present
			if tKey is among the keys of pArray[tOriginalKey] then
				put pArray[tOriginalKey][tKey] into tElement[tKey]
			else
				put defaultNavElement(tKey) into tElement[tKey]
			end if
		end repeat

		--RAD Change no "New Item" in label if iconFill is active
		if tElement["label"] is "" then
			if mIconFill then
				put "" into tElement["label"]
			else
				put "New Item" into tElement["label"]
			end if
		end if --tElement["label"] is ""

		-- If the selected icon is the same as the icon, just put empty into the selected icon name
		-- that way, when the icon is changed, the selected icon will change too.
		if tElement["hilited_icon_name"] is tElement["icon_name"] then
			put "" into tElement["hilited_icon_name"]
		end if
		push tElement onto tList
	end repeat --for each element tOrderKey in tOrder

	put tList into rList
end handler --setData



private handler getDataElement(in pElementName as String, in pList as List) returns String
	variable tList
	put the empty list into tList

	variable tElement
	repeat for each element tElement in pList
		push tElement[pElementName] onto tList
	end repeat

	variable tElements
	combine tList with "," into tElements
	return tElements
end handler



private handler setDataElement(in pElementName as String, in pElements as String, in pDefaultArray as Array, inout xList as List)
	variable tElements
	split pElements by "," into tElements

	variable tCount
	put 0 into tCount

	variable tElement
	repeat for each element tElement in xList
		add 1 to tCount
		if tCount > the number of elements in tElements then
			put pDefaultArray[pElementName] into xList[tCount][pElementName]
		else
			put tElements[tCount] into xList[tCount][pElementName]
		end if
	end repeat

	// If we there are more of the given element than there are items, generate more
	add 1 to tCount
	repeat with tCount from tCount up to the number of elements in tElements
		push pDefaultArray onto xList
		put tElements[tCount] into xList[tCount][pElementName]
	end repeat

	put true into mRecalculate
	post "navDataChanged"
	redraw all
end handler



-- Only the primary data element ("name" for both actions and nav) can *reduce*
-- the number of elements in the data list.
private handler setPrimaryDataElement(in pElementName as String, \
	in pElements as String, in pUnique as Boolean, \
	in pDefaultArray as Array, inout xList as List)
	variable tElements as List
	variable tElement as String
	variable tCount as Number

	split pElements by "," into tElements

		-- Enforce uniqueness, if requested
	if pUnique then
		put 0 into tCount
		repeat with tCount from 1 up to the number of elements in tElements
			if the index of tElements[tCount] after tCount in tElements is not 0 then
				throw "duplicate" && pElementName && tElements[tCount]
				return
			end if
		end repeat
	end if

	put 0 into tCount
	repeat for each element tElement in tElements
		add 1 to tCount
		if tCount > the number of elements in xList then
			push pDefaultArray onto xList
		end if

		put tElement into xList[tCount][pElementName]
	end repeat

	// If we there are more items than there are primary elements, pop them off.
	add 1 to tCount
	repeat with tCount from tCount up to the number of elements in xList
		pop xList
	end repeat

	put true into mRecalculate
	post "dataChanged"
	redraw all
end handler



private handler stringToInt ( in pString as String ) returns optional Integer
	-- no matter what comes in as pString, we get an integer out, 0 or otherwise. reals are truncated
	variable rNumber as optional Integer
	parse pString as number into rNumber
	if rNumber is nothing then
		put 0 into rNumber
	else
		put rNumber - ( rNumber mod 1 ) into rNumber -- subtract the real part to get an integer
	end if
	return rNumber
end handler

--------------------------------------------------------------------------------
--
--		Nav data handling
--
--------------------------------------------------------------------------------

private handler defaultNavElement(in pKey as String) returns String
	if pKey is "name" then
		return kDefaultNavName
	else if pKey is "label" then
		return kDefaultNavLabel
	else if pKey is "icon_name" then
		return kDefaultNavIconName
	else if pKey is "hilited_icon_name" then
		return ""
	else if pKey is "icon" then
		return ""
	else if pKey is "hilited_icon" then
		return ""
	end if
	return ""
end handler



private handler defaultNavArray() returns Array
	variable tArray as Array
	put the empty array into tArray
	put kDefaultNavName into tArray["name"]
	put kDefaultNavLabel into tArray["label"]
	put kDefaultNavIconName into tArray["icon_name"]
	put "" into tArray["hilited_icon_name"]
	put "" into tArray["icon"]
	put "" into tArray["hilited_icon"]
	put "" into tArray["manual_path"]
	put "" into tArray["manual_hilited_path"]
	return tArray
end handler



private handler navDataDifferent(in pLeft as List, in pRight as List) returns Boolean
	if the number of elements in pLeft is not the number of elements in pRight then
		return true
	end if

	variable tIndex as Number
	repeat with tIndex from 1 up to the number of elements in pLeft
		if pLeft[tIndex]["label"] is not pRight[tIndex]["label"] then
			return true
		end if

		if pLeft[tIndex]["icon_name"] is not pRIght[tIndex]["icon_name"] then
			return true
		end if

		if pLeft[tIndex]["hilited_icon_name"] is not pRight[tIndex]["hilited_icon_name"] then
			if not (pLeft[tIndex]["hilited_icon_name"] is "" and pRight[tIndex]["hilited_icon_name"] is pRight[tIndex]["icon_name"]) and not (pLeft[tIndex]["hilited_icon_name"] is pLeft[tIndex]["icon_name"] and pRight[tIndex]["hilited_icon_name"] is "") then
				return true
			end if
		end if

		if pLeft[tIndex]["manual_path"] is not pRight[tIndex]["manual_path"] or pLeft[tIndex]["manual_hilited_path"] is not pRight[tIndex]["manual_hilited_path"] then
			return true
		end if
	end repeat
	return false
end handler



private handler getNavData() returns Array
	return listToArray(mNavData)
end handler



private handler setNavData(in pNavData as Array)
	variable tNavData as List
	setData(pNavData, the keys of defaultNavArray(), tNavData)
	if navDataDifferent(tNavData, mNavData) then
		put tNavData into mNavData
		put true into mRecalculate
		post "dataChanged"
		redraw all
	end if
end handler



private handler getNavNames() returns String
	return getDataElement("name", mNavData)
end handler



private handler setNavNames(in pNames as String)
	setPrimaryDataElement("name", pNames, true, defaultNavArray(), mNavData)
end handler



private handler getNavIcons() returns String
	return getDataElement("icon_name", mNavData)
end handler



private handler setNavIcons(in pIcons as String)
	setDataElement("icon_name", pIcons, defaultNavArray(), mNavData)
end handler



private handler getNavSelectedIcons() returns String
	return getDataElement("hilited_icon_name", mNavData)
end handler



private handler setNavSelectedIcons(in pIcons as String)
	setDataElement("hilited_icon_name", pIcons, defaultNavArray(), mNavData)
end handler



private handler getNavLabels() returns String
	return getDataElement("label", mNavData)
end handler



private handler setNavLabels(in pLabels as String)
	setDataElement("label", pLabels, defaultNavArray(), mNavData)
end handler



private handler addItem(in pItem as Number)
	if mNavData is [] then
		push defaultNavArray() onto mNavData
	else
		splice [defaultNavArray()] after element pItem of mNavData
	end if
	put true into mRecalculate
	post "dataChanged"
	redraw all
end handler



private handler deleteItem(in pItem as Number)
	delete element pItem of mNavData
	put true into mRecalculate
	post "dataChanged"
	redraw all
end handler



private handler moveItem(in pFrom as Number, in pTo as Number) returns nothing
	-- Do nothing if this isn't really a move.
	if pFrom is pTo then
		return
	end if

	variable tItem as Array
	put mNavData[pFrom] into tItem
	delete element pFrom of mNavData
	if pTo is 1 then
		splice [tItem] before element 1 of mNavData
	else
		splice [tItem] after element (pTo - 1) of mNavData
	end if
	post "dataChanged"
	put true into mRecalculate
end handler



private handler reorderItem(in pItem as Number)
	put {} into mDragData
	put the y of the mouse position - ((pItem - 1) * kEditModeLineHeight) into mDragData["offset"]
	put pItem into mDragData["item"]
	put mNavData[pItem]["label"] into mDragData["label"]
	redraw all
end handler



private handler dragDrop() returns nothing
	if mDragData is nothing then
		return
	end if

	if "target" is among the keys of mDragData then
		if mDragData["item"] > mDragData["target"] then
			moveItem(mDragData["item"], mDragData["target"] + 1)
		else if mDragData["target"] > mDragData["item"] then
			moveItem(mDragData["item"], mDragData["target"])
		end if
		put nothing into mDragData
		redraw all
	end if
end handler



private handler getDesiredHeight() returns Number
	if mEditMode and mNavItemCount is not 0 then
		return kEditModeLineHeight * mNavItemCount
	end if

	return kEditModeLineHeight
end handler



private handler setShowDivide(in pShowDivide as Boolean) returns nothing
	if pShowDivide is mShowDivide then
		return
	end if

	put pShowDivide into mShowDivide
	redraw all
end handler



--private handler setNoDefault(in pNoDefault as Boolean) returns nothing
	--if pNoDefault is mNoDefault then
		--return
	--end if

	--put pNoDefault into mNoDefault
	--redraw all
--end handler

-- RAD Change Set for now property iconFill
private handler setIconFill(in pIconFill as Boolean) returns nothing
	if pIconFill is mIconFill then
		return
	end if

	put pIconFill into mIconFill
	--put true into mRecalculate
	--setNavData(pProperties["items"])
	--calculateIconRects()
	--if not mEditMode then
		--drawNavRad()
	--else
		--drawNavRadEditMode()
	--end if
	--redraw all

	put true into mRecalculate
	post "dataChanged"
	redraw all

end handler



private handler setNavIconZoom(in pIconZoom as Number) returns nothing
	if pIconZoom is mIconZoom then
		return
	end if

	put pIconZoom into mIconZoom
	put true into mRecalculate
	post "dataChanged"
	redraw all
end handler



-- RAD Change Set for now property autoRADHilite
private handler setAutoRADHilite(in pAutoRADHilite as Boolean) returns nothing
	if pAutoRADHilite is mAutoRADHilite then
		return
	end if

	put pAutoRADHilite into mAutoRADHilite
	redraw all
end handler



private handler setShowBackground(in pShowBackground as Boolean) returns nothing
	if pShowBackground is mShowBackground then
		return
	end if

	put pShowBackground into mShowBackground
	redraw all
end handler



private handler getLeftMargin () returns Integer
	return element 1 of mMargins
end handler



private handler getTopMargin () returns Integer
	return element 2 of mMargins
end handler



private handler getRightMargin () returns Integer
	return element 3 of mMargins
end handler



private handler getBottomMargin () returns Integer
	return element 4 of mMargins
end handler



private handler getMargins () returns String
	-- converts the margins from a list to a string and returns it, e.g. 0,0,0,0
	variable tElement as Integer
	variable tElementAsString as String
	variable tMargins as String
	put the empty string into tMargins
	repeat for each element tElement in mMargins
		format tElement as string into tElementAsString
		put tElementAsString  & "," after tMargins
	end repeat
	delete the last char of tMargins
	return tMargins
end handler



private handler setLeftMargin ( in pValue as Integer ) returns nothing
	setMargin ( 1 , pValue )
end handler



private handler setTopMargin ( in pValue as Integer ) returns nothing
	setMargin ( 2 , pValue )
end handler



private handler setRightMargin ( in pValue as Integer ) returns nothing
	setMargin ( 3 , pValue )
end handler



private handler setBottomMargin ( in pValue as Integer ) returns nothing
	setMargin ( 4 , pValue )
end handler



private handler setMargin ( in pIndex  as Integer , in pValue as Integer ) returns nothing
	put pValue into element pIndex of mMargins
	put true into mRecalculate
	redraw all
end handler



private handler setMargins ( in pMargins as String ) returns nothing
	-- takes a string "0,0,0,0" and sets mMargins (a list) as [0,0,0,0]
	variable tMargins as List
	variable tMargin as String
	put the empty list into mMargins

	split pMargins by "," into tMargins
	repeat for each element tMargin in tMargins
		push stringToInt ( tMargin ) onto mMargins
	end repeat
	put true into mRecalculate
	redraw all
end handler



private handler setTraditionalMargins ( in pBool as Boolean ) returns nothing
	if pBool is mTraditionalMargins then
		return
	else
		put pBool into mTraditionalMargins
		put true into mRecalculate
		redraw all
	end if
end handler

--------------------------------------------------------------------------------
--
--		Editable rect things
--
--------------------------------------------------------------------------------

handler type PopupCallback(in pPopupResult as optional any, in pType as String, in pNumber as Number)
handler type ActionCallback(in pNumber as Number)

private variable mEditData as Array


public handler initialiseEditData()
	put the empty array into mEditData
end handler



public handler setEditableRect(in pComponent as String, in pNumber as Number, \
	in pRect as Rectangle, in pTooltip as String, in pPopup as String, \
	in pCallback as PopupCallback)
	variable tComponentID as String
	put pComponent && pNumber formatted as string into tComponentID

	put the empty array into mEditData[tComponentID]

	put pRect into mEditData[tComponentID]["rect"]
	put pTooltip into mEditData[tComponentID]["tooltip"]
	put pPopup into mEditData[tComponentID]["popup"]
	put pCallback into mEditData[tComponentID]["callback"]
	put pComponent into mEditData[tComponentID]["type"]
	put pNumber into mEditData[tComponentID]["number"]
	put true into mEditData[tComponentID]["mouseup"]
end handler



public handler setEditableTextRect(in pComponent as String, \
	in pNumber as Number, in pRect as Rectangle, in pTooltip as String)
	variable tComponentID as String
	put pComponent && pNumber formatted as string into tComponentID

	put the empty array into mEditData[tComponentID]

	put pRect into mEditData[tComponentID]["rect"]
	put pTooltip into mEditData[tComponentID]["tooltip"]
	put pComponent into mEditData[tComponentID]["type"]
	put pNumber into mEditData[tComponentID]["number"]
	put true into mEditData[tComponentID]["mouseup"]
end handler



public handler setActionRect(in pComponent as String, in pNumber as Number, \
	in pRect as Rectangle, in pTooltip as String, \
	in pAction as ActionCallback, in pMouseUp as Boolean)
	variable tComponentID as String
	put pComponent && pNumber formatted as string into tComponentID

	put the empty array into mEditData[tComponentID]

	put pRect into mEditData[tComponentID]["rect"]
	put pTooltip into mEditData[tComponentID]["tooltip"]
	put pComponent into mEditData[tComponentID]["type"]
	put pNumber into mEditData[tComponentID]["number"]
	put pAction into mEditData[tComponentID]["action"]
	put pMouseUp into mEditData[tComponentID]["mouseup"]
end handler



public handler drawEditableRects(in pCanvas as Canvas)
	variable tElement as Array
	repeat for each element tElement in mEditData
		set the paint of pCanvas to solid paint with color [0,0,0]
		stroke rectangle path of tElement["rect"] on pCanvas
	end repeat
end handler



private handler widgetClicked(in pClickPosition as Point, in pMouseUp as Boolean)
	if pMouseUp then
		dragDrop()
	end if

	variable tElement as Array
	repeat for each element tElement in mEditData
		if tElement["mouseup"] is pMouseUp and pClickPosition is within tElement["rect"] then
			if "popup" is among the keys of tElement then
				doPopup(pClickPosition, tElement)
			else if "action" is among the keys of tElement then
				doAction(tElement)
			else
				addEditableField(tElement)
			end if
		end if
	end repeat
end handler



private handler doPopup(in pClickPos as Point, in pArray as Array)
	variable tResult

	-- Popup the icon picker with the currently selected icon as the initial selection
	variable tProperties as Array
	put the empty array into tProperties
	if pArray["type"] is "selectedIcon" and mNavData[pArray["number"]]["hilited_icon_name"] is not "" then
		put mNavData[pArray["number"]]["hilited_icon_name"] into tProperties["selectedIcon"]
	else
		put mNavData[pArray["number"]]["icon_name"] into tProperties["selectedIcon"]
	end if

	popup widget pArray["popup"] at pClickPos with properties tProperties
	put the result into tResult

	variable tCallback as PopupCallback
	put pArray["callback"] into tCallback
	tCallback(tResult, pArray["type"], pArray["number"])
end handler



private handler doAction(in pArray as Array)
	variable tCallback as ActionCallback
	put pArray["action"] into tCallback
	tCallback(pArray["number"])
end handler



private handler formatRectAsString(in pRect as Rectangle)
	variable tResult as String
	put (the left of pRect) formatted as string into tResult
	put "," & (the top of pRect) formatted as string after tResult
	put "," & (the right of pRect) formatted as string after tResult
	put "," & (the bottom of pRect) formatted as string after tResult
	return tResult
end handler



private handler addEditableField(in pElement as Array)
	-- Work around the fact that LCB currently doesn't have editable text fields
	post "editField" with [formatRectAsString(pElement["rect"]), pElement["number"]]
end handler



--------------------------------------------------------------------------------
--
--		utilities
--
--------------------------------------------------------------------------------
private handler Beep()
	execute script "beep"
end handler



private handler Answer (in pPrompt as String, in pOKLabel as String, in pCancelLabel as String) returns String
	variable tCancelClause as String
	variable tOKClause as String
	variable tConjunction as String

	put the empty string into tConjunction
	put the empty string into tCancelClause
	-- <manage button labels>
		if ( pCancelLabel is empty and pOKLabel is empty ) then
			-- assume ok and cancel are both to be assigned
			put "\qOK\q" into tOKClause
			put "and" into tConjunction
			put "\qCancel\q" into tCancelClause
		else if pCancelLabel is empty then
			-- ok defined, but cancel is not, so assume only ok used
			put "\q" & pOKLabel & "\q" into tOKClause
		else if pOKLabel is empty then
			put "\qOK\q" into tOKClause
			put "\q" & pCancelLabel & "\q" into tCancelClause
		else 
			-- both defined
			put "\q" & pOKLabel & "\q" into tOKClause
			put "and" into tConjunction
			put "\q" & pCancelLabel & "\q" into tCancelClause
		end if --pCancelLabel is empty and pOKLabel is empty
	--</manage button labels>
	execute script "answer \q" & pPrompt & "\q with " & tCancelClause && tConjunction && tOKClause &"; return it"
	return the result
end handler



private handler Message ( in pPrompt as String, in pBeforeAfterInto as String ) returns nothing
	-- can't embed a "\r" when sending over the wall into LCS, so have to have extra options like these
	if pBeforeAfterInto is "beforeLine" then
		execute script "put cr before msg"
		put "before" into pBeforeAfterInto
	else if pBeforeAfterInto is "afterLine" then
		execute script "put cr after msg"
		put "after" into pBeforeAfterInto
	end if

	execute script "put \q" & pPrompt & "\q" && pBeforeAfterInto && "msg"
end handler

end widget
